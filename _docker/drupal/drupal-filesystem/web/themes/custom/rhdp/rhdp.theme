<?php

/**
 * @file
 * Functions to support theming in the RHDP theme.
 */

use Drupal\block\Entity\Block;
use Drupal\Core\Asset\AttachedAssetsInterface;
use Drupal\Core\Link;
use Drupal\Core\Url;
use Drupal\file\Entity\File;
use Drupal\image\Entity\ImageStyle;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\Core\Menu\MenuTreeParameters;
use Drupal\Core\Block\Plugin\Block\Broken;
use Drupal\Core\Access\AccessResult;

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function rhdp_theme_suggestions_page_alter(array &$suggestions, array $variables) {
  $node = \Drupal::request()->attributes->get('node');

  if (!is_null($node) && method_exists($node, 'getType')) {
    $new_suggestion = 'page__' . $node->getType();

    if (!in_array($new_suggestion, $suggestions)) {
      $suggestions[] = $new_suggestion;
    }
  }

  return $suggestions;
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 *
 * Ensures theme suggestions exist for every content type.
 */
function rhdp_theme_suggestions_node_alter(array &$suggestions, array $variables) {
  $found_suggestion_matches = preg_grep("/node__\D+__/", $suggestions);

  // If we have found_suggestion_matches, just return those as they'll be more
  // specific anyway. This does feel kind of hacky, but not sure of a better
  // solution.
  if (!is_null($found_suggestion_matches)) {
    return $suggestions;
  }

  $node = \Drupal::request()->attributes->get('node');

  if (!is_null($node) && method_exists($node, 'getType')) {
    $new_suggestion = 'node__' . $node->getType();

    if (!in_array($new_suggestion, $suggestions)) {
      $suggestions[] = $new_suggestion;
    }
  }

  return $suggestions;
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function rhdp_theme_suggestions_block_alter(array &$suggestions, array $variables) {
  $node = \Drupal::request()->attributes->get('node');
  $suggestion = 'block';
  $parts = explode(':', $variables['elements']['#plugin_id']);

  if (!is_null($node) && method_exists($node, 'getType')) {
    $suggestions[] = $suggestion .= '__' . $node->getType();
  }

  while ($part = array_shift($parts)) {
    $suggestions[] = $suggestion .= '__' . strtr($part, '-', '_');
  }

  return $suggestions;
}

/**
 * Implements hook_preprocess_block().
 */
function rhdp_preprocess_block(array &$variables) {
  // Verify that the #id has some non-empty value prior to using it.
  if (!empty($variables['elements']['#id'])) {
    $block_id = $variables['elements']['#id'];

    if ($block_id == 'rhdnavigation_mobile') {
      $variables['attributes']['class'][] = 'rhd-nav-mobile';
    }

    if ($block_id == 'rhdnavigation') {
      $variables['attributes']['class'][] = 'rhd-nav-fixed';
    }
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function rhdp_theme_suggestions_toc_responsive_alter(array &$suggestions, array $variables) {
  $node = \Drupal::request()->attributes->get('node');
  $suggestion = 'toc_responsive';
  $parts = explode(':', $variables['elements']['#plugin_id']);

  if (!is_null($node) && method_exists($node, 'getType')) {
    $suggestions[] = $suggestion .= '__' . $node->getType();
  }

  while ($part = array_shift($parts)) {
    $suggestions[] = $suggestion .= '__' . strtr($part, '-', '_');
  }

  return $suggestions;
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function rhdp_theme_suggestions_taxonomy_term_alter(array &$suggestions, array $variables) {
  $suggestion = 'taxonomy_term';
  $term = $variables['elements']['#taxonomy_term'];
  $node = \Drupal::request()->attributes->get('node');

  if (!is_null($node) && method_exists($node, 'getType')) {
    $suggestions[] = $suggestion .= '__' . $node->getType();
  }

  $suggestions[] = $suggestion . '__' . $term->bundle();
  $suggestions[] = $suggestion . '__' . $term->id();

  return $suggestions;
}

/**
 * Implements hook_preprocess_html().
 */
function rhdp_preprocess_html(array &$variables) {
  $current_path = \Drupal::service('path.current')->getPath();
  // Retrieve the redhat_developers config configuration object once.
  $rhd_config = \Drupal::config('redhat_developers');
  // Get the current node object.
  $node = \Drupal::request()->attributes->get('node');

  // If we could not fetch the Node object from the Request. This should only
  // happen on the Product pages, due to the highly custom 1 Node to multiple
  // routes implementation.
  if (empty($node) || !($node instanceof NodeInterface)) {
    $node = _get_product_node_from_request();
  }

  // Retrieve individual config values from the config object.
  $environment = $rhd_config->get('environment');
  $dtm_code = $rhd_config->get('dtm_code');
  $sentry_track = $rhd_config->get('sentry_track');
  $sentry_script = $rhd_config->get('sentry_script');
  $sentry_code = $rhd_config->get('sentry_code');
  $rhd_base_url = $rhd_config->get('rhd_base_url');
  $rhd_final_base_url = $rhd_config->get('rhd_final_base_url');

  $variables['rhd_environment'] = $environment;
  $variables['rhd_dtm_code'] = $dtm_code;
  $variables['rhd_dtm_script'] = redhat_www_ddo_default($node);
  $variables['rhd_sentry_track'] = $sentry_track;
  $variables['rhd_sentry_script'] = $sentry_script;
  $variables['rhd_sentry_code'] = $sentry_code;
  $variables['rhd_base_url'] = $rhd_base_url;
  $variables['rhd_final_base_url'] = $rhd_final_base_url;
  $variables['current_path'] = \Drupal::service('path.alias_manager')->getAliasByPath($current_path);

  if ($environment != 'prod') {
    $referrer = [
      '#tag' => 'meta',
      '#attributes' => [
        // Set name for element.
        'name' => 'referrer',
        // Set value for title.
        'value' => 'unsafe-url',
      ],
    ];

    $variables['page']['#attached']['html_head'][] = [$referrer, 'referrer'];
  }
}

/**
 * Gets the Product node for a given route.
 *
 * This helper function returns the Product node for a given route. This is
 * necessary because of our custom Product implementations that serve multiple
 * routes from a single Node.
 *
 * @return \Drupal\node\NodeInterface|null
 *   Return a Node object if this is a Product node. Otherwise, return NULL.
 */
function _get_product_node_from_request() {
  $request_uri = \Drupal::request()->getRequestUri();

  if (!empty($request_uri)) {
    // Trim any leading and trailing slashes so that we can explode() below.
    $request_uri_trimmed = trim($request_uri, '/');
    $request_uri_pieces = explode('/', $request_uri_trimmed);

    if ($request_uri_pieces[0] === 'products') {
      $product_url_name = $request_uri_pieces[1];
    }
    // Else, we are not looking at a Product page. Return NULL.
    else {
      return NULL;
    }
  }
  if (!empty($product_url_name)) {
    $products = \Drupal::service('rhd_assemblies.download_manager_api')->getProductNodesByProductUrlName($product_url_name);

    // Grab the first product in the array. There should always only be a single
    // Product node returned, since the product_url_name should be unique.
    if ($product = reset($products)) {
      // If we've successfully retrieved a product Node object by the
      // product_url_name, then assign it to $node.
      if (!empty($product) && $product instanceof NodeInterface) {
        return $product;
      }
    }
  }
}

/**
 * Implements hook_js_settings_alter().
 */
function rhdp_js_settings_alter(array &$settings, AttachedAssetsInterface $assets) {
  $env_settings = \Drupal::config('redhat_developers');

  $settings['rhd'] = [];
  $rhd_settings = &$settings['rhd'];

  $rhd_settings['urls'] = [];
  $rhd_settings['urls']['final_base_url'] = $env_settings->get('rhd_final_base_url');

  $rhd_settings['downloadManager'] = [];
  $rhd_settings['downloadManager']['baseUrl'] = $env_settings->get('downloadManager')['baseUrl'];
  $rhd_settings['dcp']['baseProtocolRelativeUrl'] = $env_settings->get('searchisko')['protocol'] . "://" . $env_settings->get('searchisko')['host'] . ":"
      . $env_settings->get('searchisko')['port'];

  $rhd_settings['keycloak'] = [];
  $rhd_settings['keycloak']['accountUrl'] = $env_settings->get('keycloak')['accountUrl'];
  $rhd_settings['keycloak']['authUrl'] = $env_settings->get('keycloak')['authUrl'];
  $rhd_settings['keycloak']['client_id'] = $env_settings->get('keycloak')['client_id'];
  $rhd_settings['keycloak']['realm'] = $env_settings->get('keycloak')['realm'];

  $rhd_settings['swel'] = [];
  $rhd_settings['swel']['url'] = $env_settings->get('swel')['url'];

  $rhd_settings['fusion'] = [];
  $rhd_settings['fusion']['url'] = $env_settings->get('fusion')['url'];

  $theme_path = drupal_get_path('theme', 'rhdp');

  $rhd_settings['templates'] = [];
  $template = file_get_contents($theme_path . '/templates/client-side/book.html.twig');
  $rhd_settings['templates']['book'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/mini_buzz.html.twig');
  $rhd_settings['templates']['miniBuzz'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/product_buzz.html.twig');
  $rhd_settings['templates']['productBuzz'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/buzz.html.twig');
  $rhd_settings['templates']['buzz'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/terms_conditions.html.twig');
  $rhd_settings['templates']['termsConditions'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/product_connector.html.twig');
  $rhd_settings['templates']['connector'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/product_stackoverflow_template.html.twig');
  $rhd_settings['templates']['productStackoverflowTemplate'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/search_page_template.html.twig');
  $rhd_settings['templates']['searchPageTemplate'] = $template;

  $template = file_get_contents($theme_path . '/templates/client-side/stackoverflow_template.html.twig');
  $rhd_settings['templates']['stackoverflowTemplate'] = $template;
}

/**
 * Implements template_preprocess_page().
 */
function rhdp_preprocess_page(&$variables) {

  $node = isset($variables['node']) ? $variables['node'] : FALSE;

  if ($node && get_class($node) === 'Drupal\node\Entity\Node') {
    $alias = \Drupal::service('path.alias_manager')->getAliasByPath('/node/' . $node->id());

    if ($alias == '/') {
      $variables['is_front'] = TRUE;
    }
  }

  // Pull out assemblies to page level for solp.
  if ($node && get_class($node) === 'Drupal\node\Entity\Node' && $node->getType() == 'landing_page_single_offer') {
    foreach (['hero'] as $field) {
      $fieldname = 'field_' . $field;
      if (isset($node->$fieldname)) {
        $viewBuilder = \Drupal::entityTypeManager()->getViewBuilder('node');
        $output = $viewBuilder->viewField($node->$fieldname, 'full');
        $output['#cache']['tags'] = $node->getCacheTags();
        $variables['page'][$field] = $output;
      }
    }
  }

}

/**
 * Implements template_preprocess_node().
 */
function rhdp_preprocess_node(array &$variables) {
  $variables['node'] = $variables['elements']['#node'];
  $node = $variables['node'];

  // Product content type and Featured Tile view mode.
  if ($node->getType() == 'product' && $variables['view_mode'] == 'featured_tile') {
    $product_code = $node->get('field_product_machine_name')->getValue();

    if (count($product_code)) {
      $product_code = reset($product_code);
      $variables['logo_link'] = \Drupal::service('path.alias_manager')->getAliasByPath('/products/' . $product_code['value']);
    }

    $variables['cta_url'] = FALSE;
    $variables['cta_title'] = ['#markup' => 'Learn More'];
    $cta_field = $node->get('field_call_to_action_link')->getValue();

    if (count($cta_field)) {
      $cta_field = reset($cta_field);
      $variables['cta_title']['#markup'] = $cta_field['title'];
      $url = Url::fromUri($cta_field['uri']);
      $variables['cta_url']['#markup'] = $url->toString();

      if (!$url->isExternal()) {
        $variables['cta_url']['#markup'] = \Drupal::service('path.alias_manager')->getAliasByPath($url->toString());
      }
    }
  }

  // Product content type and Product Download Page view mode.
  if ($node->getType() == 'product' && $variables['view_mode'] == 'product_download_page') {
    if (isset($node->field_product_machine_name)) {
      $product_code = $node->get('field_product_machine_name')->value;

      // Retrieve the data on this product from Download Manager.
      $content = \Drupal::service('rhd_assemblies.download_manager_api')->getContentById($product_code);

      // Build an array of the versions of this product.
      foreach ($content[0]->productVersions as $key => $version) {
        $versions[$key] = $version;

        foreach ($version->files as $file_key => $file) {
          $versions[$key]->files[$file_key]->fileSize = format_size($file->fileSize)->__toString();
        }
      }

      $variables['versions'] = $versions;
      $variables['featured'] = $content[0]->featuredArtifact;
    }
  }

  // Add icon for 'login required' resources.
  if ($variables['view_mode'] == 'card') {
    $variables['login_req'] = FALSE;
    $dm_fields = [
      'field_book_url',
      'field_cheat_sheet_download_url',
      'field_source_link',
      'field_pdf_link',
      'field_mobi_link',
      'field_epub',
    ];

    foreach ($dm_fields as $field) {
      if ($node->hasField($field)) {
        $ext_url = $node->get($field)->getValue();
        if (count($ext_url)) {
          $ext_url_uri = reset($ext_url)['uri'];
          if (strpos($ext_url_uri, 'developers.redhat.com/download-manager/') !== FALSE) {
            $variables['login_req'] = TRUE;
            // We have a download-manager link break loop no need to continue!
            break;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_paragraph__PARAGRAPH_TYPE().
 */
function rhdp_preprocess_paragraph__connectors(&$variables) {
  $block = Block::load('views_block__connectors_rest_export_connectors_rest_export_block');
  $render = \Drupal::entityTypeManager()
    ->getViewBuilder('block')
    ->view($block);

  $variables['connectors_block'] = $render;
}

/**
 * Creates a digital data object (DDO) for Adobe Dynamic Tag Management (DTM).
 *
 * @param \Drupal\Entity\node\Node|null $node
 *   This function will expects a Node object if the current request/page is a
 *   Node. Otherwise, it expects NULL.
 *
 * @return array
 *   Returns an associative array populated with data used to populate the
 *   digitalData JS object.
 */
function redhat_www_ddo_default($node) {
  $request = \Drupal::request();
  $siteerror = \Drupal::configFactory()->get('system.site')->get('page.404');
  $errorType = "";
  $errorMessage = "";
  $ddo_language = "";
  $ddo_pageID = "";
  $ddo_title = "";

  if (!empty($node) && $node instanceof NodeInterface) {
    if ($siteerror == '/node/' . $node->nid->value) {
      $errorType = "404";
      $errorMessage = "404-error";
    }

    $ddo_language = $node->langcode->value;
    $ddo_pageID = $node->nid->value;
    $ddo_title = $node->title->value;
    $ddo_taxonomies = _get_all_taxonomy_terms($node);
  }

  $ddo = [
    'page' => [
      'attributes' => [
        'queryParameters' => '',
        'taxonomyAudience' => $ddo_taxonomies['field_tax_audience_segment'] ?? [],
        'taxonomyBusinessUnit' => $ddo_taxonomies['field_tax_business_unit'] ?? [],
        'taxonomyCampaign' => $ddo_taxonomies['field_tax_campaign'] ?? [],
        'taxonomyLifecycle' => $ddo_taxonomies['field_tax_lifecycle'] ?? [],
        'taxonomyProduct' => $ddo_taxonomies['field_tax_product'] ?? [],
        'taxonomyProductLine' => $ddo_taxonomies['field_tax_product_line'] ?? [],
        'taxonomyProject' => $ddo_taxonomies['field_tax_project'] ?? [],
        'taxonomyPromotion' => $ddo_taxonomies['field_tax_promotion'] ?? [],
        'taxonomyRegion' => $ddo_taxonomies['field_tax_region'] ?? [],
      ],
      'category' => [
        'contentType' => '',
        'contentSubType' => '',
        'keyPage' => FALSE,
        'keyPageType' => '',
        'pageType' => '',
        'primaryCategory' => '',
        'subCategories' => [],
      ],
      'pageInfo' => [
        'breadCrumbs' => [],
        'cms' => 'RHD CMS 8',
        'destinationURL' => '',
        'errorMessage' => $errorMessage,
        'errorType' => $errorType,
        'language' => $ddo_language,
        'pageID' => $ddo_pageID,
        'contentID' => $ddo_pageID,
        'pageName' => '',
        'referringDomain' => '',
        'referringURL' => '',
        'syndicationIds' => [],
        'sysEnv' => '',
        'title' => $ddo_title,
      ],
      'listing' => [
        'browseFilter' => '',
        'query' => '',
        'queryMethod' => '',
        'refinementType' => '',
        'refinementValue' => '',
        'resultCount' => '',
        'searchType' => '',
      ],
    ],
    'user' => [
      [
        'profile' => [
          [
            'profileInfo' => [
              'accountID' => '',
              'daysSinceLastPurchase' => '',
              'daysSinceRegistration' => '',
              'eloquaGUID' => 'POPULATE ELOQUA ID',
              'keyCloakID' => '',
              'loggedIn' => FALSE,
              'profileID' => '',
              'registered' => FALSE,
              'socialAccountsLinked' => [],
              'subscriptionFrequency' => '',
              'subscriptionLevel' => '',
              'userAgent' => '',
            ],
          ],
        ],
      ],
    ],
    'event' => [],
  ];

  return $ddo;
}

/**
 * Gets all taxonomy terms, as labels, referenced by a $node.
 *
 * @param Drupal\node\NodeInterface $node
 *   A node to retrieve taxonomy terms from.
 *
 * @return array
 *   An array of taxonomy terms, keyed by fieldname.
 */
function _get_all_taxonomy_terms(NodeInterface $node) {
  // Attempt to retrieve the taxonomy terms reference by the following fields.
  $taxonomy_fields = [
    'field_tax_audience_segment' => 'field_tax_audience_segment',
    'field_tax_business_unit' => 'field_tax_business_unit',
    'field_tax_campaign' => 'field_tax_campaign',
    'field_tax_lifecycle' => 'field_tax_lifecycle',
    'field_tax_product' => 'field_tax_product',
    'field_tax_product_line' => 'field_tax_product_line',
    'field_tax_project' => 'field_tax_project',
    'field_tax_promotion' => 'field_tax_promotion',
    'field_tax_region' => 'field_tax_region',
  ];
  // Initialize an array to collect taxonomy terms for the Adobe DDO object.
  $ddo_taxonomies = [];

  foreach ($taxonomy_fields as $taxonomy_field) {
    // If this $node does not have one of the fields, set an empty array.
    if (!$node->hasField($taxonomy_field)) {
      $ddo_taxonomies[$taxonomy_field] = [];
    }
    else {
      // Get the referenced taxonomy terms.
      $terms = $node->get($taxonomy_field)->referencedEntities();

      // If this $node is referencing taxonomy terms, push them onto the
      // $ddo_taxonomies array, keyed by the fieldname.
      if (!empty($terms)) {
        foreach ($terms as $term) {
          $ddo_taxonomies[$taxonomy_field][] = $term->id();
        }
      }
      // If this field doesn't reference any terms, set an empty array.
      else {
        $ddo_taxonomies[$taxonomy_field] = [];
      }
    }
  }

  return $ddo_taxonomies;
}

/**
 * Implements template_preprocess_field.
 *
 * Adding our css modifications to the video_embed_field type. Had to modify
 * some things mostly due to our site css so we could get the responsive
 * video to work.
 *
 */
function rhdp_preprocess_field(&$variables, $hook) {
  if ($variables['field_type'] === 'video_embed_field') {
    $variables['items'][0]['content']['#attached']['library'][] = 'rhdp/video_embed_field.responsive-video';
  }
}

/**
 * Preprocessor for the Product Groups views groups.
 */
function rhdp_preprocess_views_view_grouping__product_groups(&$variables) {
  // Replace Twig HTML comments and unwanted whitespace from the Twig title
  // variable.
  $variables['title'] = preg_replace(
    '/(<!--(.)+-->|\s)/',
    '',
    $variables['title']
  );
}

/**
 * Implements hook_library_info_alter().
 *
 * By default, we will load the Keycloak prod script. On our Stage environment
 * we will set a config object, redhat_developers.keycloak.scriptUrl, that will
 * be the URL path to the Keycloak stage script. If this config object exists,
 * then we know to override the default prod Keycloak script with the Keycloak
 * stage script.
 */
function rhdp_library_info_alter(array &$libraries, $extension) {
  $rhd_config = \Drupal::config('redhat_developers');

  // Verify that the Keycloak config key/value exists and the scriptUrl index
  // exists within that config key/value pair.
  //
  // NOTE: If this is not set, then the library will not be altered, and
  // whatever key/values provides in the RHDP theme's libraries.yml file will
  // be used.
  if ($rhd_config->get('keycloak') && isset($rhd_config->get('keycloak')['scriptUrl'])) {
    // This should return the stage Keycloak script URL on our Stage
    // environment, but otherwise, the config object will not be set, and this
    // will be NULL.
    $keycloak_url = $rhd_config->get('keycloak')['scriptUrl'];

    // Keycloak_url is only set on the Stage environment.
    if ($extension == 'rhdp' && $keycloak_url !== NULL) {
      // Remove the Prod Keycloak script URL from our library.
      unset($libraries['base-theme']['js']['https://sso.redhat.com/auth/js/keycloak.js']);
      // Add the Stage Keycloak script URL to our library.
      $libraries['base-theme']['js'][$keycloak_url] = [
        'type' => 'external',
        'minified' => FALSE,
      ];
    }
  }
}

/**
 * Implements hook_preprocess_views_view_fields().
 */
function rhdp_preprocess_views_view_fields(&$variables) {
  // Properly validates and retrieves the URL and string values that will be
  // used to render links in the connectors_rest_export views_view_fields Twig
  // template.
  //
  // @see views-view-fields--connectors_rest_export--connectors_rest_export_block.html.twig
  if ($variables['view']->id() == 'connectors_rest_export') {
    if (isset($variables['row'])) {
      // Get the Connector Node object.
      $connector = $variables['row']->_entity;

      // field_connector_link_1.
      if ($connector->hasField('field_connector_link_1') && !empty($connector->get('field_connector_link_1')[0])) {
        $field_connector_link_1 = $connector->get('field_connector_link_1');
        $field_connector_link_1_url = $field_connector_link_1[0]->getUrl()->toString();
        $field_connector_link_1_text = $connector->get('field_connector_link_1_text')->value;
      }

      // field_connector_link_2.
      if ($connector->hasField('field_connector_link_2') && !empty($connector->get('field_connector_link_2')[0])) {
        $field_connector_link_2 = $connector->get('field_connector_link_2');
        $field_connector_link_2_url = $field_connector_link_2[0]->getUrl()->toString();
        $field_connector_link_2_text = $connector->get('field_connector_link_2_text')->value;
      }

      // field_connector_details_url.
      if ($connector->hasField('field_connector_details_url') && !empty($connector->get('field_connector_details_url')[0])) {
        $field_connector_details_url = $connector->get('field_connector_details_url');
        $field_connector_details_url_link = $field_connector_details_url[0]->getUrl()->toString();
      }
    }

    // Set variables that will be used to render links in the Twig template.
    $variables['connector_link_1_url'] = $field_connector_link_1_url ?? NULL;
    $variables['connector_link_1_text'] = $field_connector_link_1_text ?? NULL;
    $variables['connector_link_2_url'] = $field_connector_link_2_url ?? NULL;
    $variables['connector_link_2_text'] = $field_connector_link_2_text ?? NULL;
    $variables['connector_details_url_link'] = $field_connector_details_url_link ?? NULL;
  }
}
